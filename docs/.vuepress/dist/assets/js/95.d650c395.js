(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{597:function(e,t,i){"use strict";i.r(t);var r=i(0),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[i("h1",{attrs:{id:"signing"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#signing"}},[e._v("#")]),e._v(" Signing")]),e._v(" "),i("p",[e._v("All of the aforementioned mechanisms require that there is a M-of-N multisignature wallet guarding each Deposit on Bitcoin.")]),e._v(" "),i("p",[e._v("Bitcoin’s consensus rules restrict script size to 520 bytes (10,000 bytes for Segwit outputs), limiting the maximum size of multisignature scripts to about 80 participants (OP_CHECKMULTISIG is limited to "),i("a",{attrs:{href:"https://github.com/bitcoin/bitcoin/blob/master/src/script/script.h#L28-L29",target:"_blank",rel:"noopener noreferrer"}},[e._v("20 public keys"),i("OutboundLink")],1),e._v(", but this can be bypassed by using "),i("code",[e._v("OP_CHECKSIG ADD")]),e._v(" and "),i("code",[e._v("<threshold> OP_GREATERTHAN")]),e._v(" as shown by "),i("a",{attrs:{href:"https://github.com/nomic-io/bitcoin-peg/blob/master/bitcoinPeg.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("Nomic Labs"),i("OutboundLink")],1),e._v("). Future proposals such as "),i("a",{attrs:{href:"https://github.com/bitcoin/bips/blob/master/bip-0114.mediawiki",target:"_blank",rel:"noopener noreferrer"}},[e._v("MAST"),i("OutboundLink")],1),e._v(" would allow implementing larger multisigs, however the activation of new features on Bitcoin has historically been a procedure with unclear timelines.")]),e._v(" "),i("p",[e._v("Finally, large multisignature wallets in Ethereum and Bitcoin both have increasing verification costs as the number of participants increases. Building multisigs on Ethereum is "),i("a",{attrs:{href:"https://www.coindesk.com/30-million-ether-reported-stolen-parity-wallet-breach",target:"_blank",rel:"noopener noreferrer"}},[e._v("particularly hard"),i("OutboundLink")],1),e._v(". By utilizing "),i("a",{attrs:{href:"https://crypto.stanford.edu/~dabo/pubs/papers/aggreg.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("aggregate signatures with public key aggregation"),i("OutboundLink")],1),e._v(", we can remove all of the above complexities and replace them by a simple single signature verification.")]),e._v(" "),i("p",[e._v('Intuitively, an aggregate public key is generated from all multisignature participants who communicate via an out of band protocol, a process also known as Distributed Key Generation (DKG). Each participant signs the intended message with their private key and contributes a "share" of the final aggregate signature. Assuming ECDSA, the aggregate signature can then be verified against the aggregate public key with an OP_CHECKSIGVERIFY on Bitcoin, or an ECRECOVER operation on Ethereum. This process is simple and inexpensive, and avoids the path of implementing complex multisignature verification logic which can be upgraded for different M-of-N configurations. If another configuration is required, the script or the smart contract only needs to be configured to use a new aggregate public key after re-executing the DKG.')]),e._v(" "),i("h2",{attrs:{id:"threshold-ecdsa"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#threshold-ecdsa"}},[e._v("#")]),e._v(" Threshold ECDSA")]),e._v(" "),i("p",[e._v("For a private key "),i("code",[e._v("x")]),e._v(", a message "),i("code",[e._v("M")]),e._v(", a hash function "),i("code",[e._v("H")]),e._v(", and a uniformly chosen "),i("code",[e._v("k")]),e._v(", an ECDSA signature is the pair "),i("code",[e._v("(r, s)")]),e._v(", where "),i("code",[e._v("s = k (m + xr)")]),e._v(", "),i("code",[e._v("r = R_x")]),e._v(","),i("code",[e._v("R = g(k-1")]),e._v(") and "),i("code",[e._v("m = H(m)")]),e._v(". Intuitively, this signature can be converted to a threshold signature if k and x are calculated via secret sharing between t of n protocol participants. "),i("a",{attrs:{href:"https://eprint.iacr.org/2019/114.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Gennaro and Goldfeder’s paper"),i("OutboundLink")],1),e._v(" describes an efficient mechanism for performing this procedure. Note that a similar mechanism was proposed by "),i("a",{attrs:{href:"https://eprint.iacr.org/2018/987.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Lindell at al"),i("OutboundLink")],1),e._v(" in the same year.")]),e._v(" "),i("p",[e._v("Informally, the participants perform the following actions to sign a message:")]),e._v(" "),i("p",[e._v("Produce an additive share of "),i("code",[e._v("k * x")]),e._v(", where each participant "),i("code",[e._v("i")]),e._v(" holds "),i("code",[e._v("k_i")]),e._v(" and "),i("code",[e._v("x_i")]),e._v(".")]),e._v(" "),i("p",[e._v("Efficiently calculate "),i("code",[e._v("R = g^(1/k)")]),e._v(" using Bar-Ilan and Beaver’s inversion trick, without any participant "),i("code",[e._v("i")]),e._v(" revealing "),i("code",[e._v("k_i")]),e._v(", and set "),i("code",[e._v("r = R_x")]),e._v(".")]),e._v(" "),i("p",[e._v("Each participant calculates their share of the signature: "),i("code",[e._v("s_i = m * k_i + r * k_i * x_i")]),e._v(".")]),e._v(" "),i("p",[e._v("The threshold signature is the sum of all signatures "),i("code",[e._v("s_i")]),e._v(".")]),e._v(" "),i("p",[e._v("A more in-depth description of the protocol can be found in Section 4.1 and 4.2 of the paper.")]),e._v(" "),i("h2",{attrs:{id:"improved-fault-attribution"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#improved-fault-attribution"}},[e._v("#")]),e._v(" Improved Fault Attribution")]),e._v(" "),i("p",[e._v("Currently, when Signers misbehave, all of their security bonds are seized and burned. If the system is parameterized to use "),i("code",[e._v("M-of-N")]),e._v(" multisigs to back deposits, this means that if "),i("code",[e._v("M")]),e._v(" parties misbehaved, the bonds of all "),i("code",[e._v("N")]),e._v(" parties would be slashed. This is a griefing vector which we ideally would like to avoid. Accountable-subgroup multisignatures (described in Section 4 of the "),i("a",{attrs:{href:"https://eprint.iacr.org/2018/483.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("related paper"),i("OutboundLink")],1),e._v(") allow distinguishing a signature made by a subgroup "),i("code",[e._v("S")]),e._v(" in a "),i("code",[e._v("M-of-N")]),e._v(" multisignature from another subgroup "),i("code",[e._v("S'")]),e._v(". This can be leveraged to penalize only the "),i("code",[e._v("M")]),e._v(" misbehaving signers, removing the risk of punishing honest signers.")]),e._v(" "),i("p",[e._v("The threshold-ECDSA protocol described in the previous section does not support fault attribution to subgroups of signers. We will deploy tBTC without that feature, and enable it in future protocol upgrades.")]),e._v(" "),i("h2",{attrs:{id:"future-signature-schemes"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#future-signature-schemes"}},[e._v("#")]),e._v(" Future Signature Schemes")]),e._v(" "),i("p",[e._v("In this section we explore other aggregate signature schemes we may use in the future. The described techniques are secure in the plain public key model, meaning that users do not need to prove ownership of their secret key, making them attractive for usage in blockchains. We briefly describe "),i("a",{attrs:{href:"https://eprint.iacr.org/2018/068",target:"_blank",rel:"noopener noreferrer"}},[e._v("MuSig"),i("OutboundLink")],1),e._v(" and "),i("a",{attrs:{href:"https://www.iacr.org/archive/asiacrypt2001/22480516.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("BLS"),i("OutboundLink")],1),e._v(" signatures.")]),e._v(" "),i("h3",{attrs:{id:"musig"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#musig"}},[e._v("#")]),e._v(" MuSig")]),e._v(" "),i("div",{staticClass:"custom-block tip"},[i("p",[e._v("This section is taken from the last section of the official "),i("a",{attrs:{href:"https://blockstream.com/2018/01/23/en-musig-key-aggregation-schnorr-signatures/",target:"_blank",rel:"noopener noreferrer"}},[e._v("MuSig"),i("OutboundLink")],1),e._v(" blogpost by Blockstream")])]),e._v(" "),i("ol",[i("li",[i("p",[e._v("Let "),i("code",[e._v("H")]),e._v(" be a cryptographic hash function")])]),e._v(" "),i("li",[i("p",[e._v("Call "),i("code",[e._v("L = H(X_1,X_2,…)")])])]),e._v(" "),i("li",[i("p",[e._v("Call "),i("code",[e._v("X")]),e._v(" the sum of all "),i("code",[e._v("H(L,X_i) * X_i")])])]),e._v(" "),i("li",[i("p",[e._v("Each signer chooses a random nonce "),i("code",[e._v("r_i, and shares R_i = r_i * G")]),e._v(" with the other signers")])]),e._v(" "),i("li",[i("p",[e._v("Call "),i("code",[e._v("R")]),e._v(" the sum of the "),i("code",[e._v("R_i")]),e._v(" points")])]),e._v(" "),i("li",[i("p",[e._v("Each signer computes "),i("code",[e._v("s_i = r_i + H(X,R,m) * H(L,X_i) * x_i")])])]),e._v(" "),i("li",[i("p",[e._v("The final signature is "),i("code",[e._v("(R,s)")]),e._v(", where "),i("code",[e._v("s")]),e._v(" is the sum of the "),i("code",[e._v("s_i")]),e._v(" values")])]),e._v(" "),i("li",[i("p",[e._v("Verification must satisfy: "),i("code",[e._v("sG = R + H(X,R,m) * X")])])])]),e._v(" "),i("p",[e._v("Contrary to earlier constructions, this signature verification algorithm is secure against rogue key attacks because X is defined as a weighted sum of the signers' public keys, where the weighting factor depends on the hash of all participating public keys.")]),e._v(" "),i("h3",{attrs:{id:"pairing-based-multisignatures"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#pairing-based-multisignatures"}},[e._v("#")]),e._v(" Pairing based multisignatures")]),e._v(" "),i("p",[e._v("Building on the work from MuSig and BLS signatures, Boneh, Drijvers and Neven introduce an efficient variant of previous BLS signature constructions which requires only 2 pairing operations for verification and is also secure against rogue key attacks.")]),e._v(" "),i("p",[e._v("This multisignature is shorter than MuSig since it is only 1 group element instead of 2. MuSig also requires an additional round of communication to generate the nonce "),i("code",[e._v("R")]),e._v(", which is not present in BLS. All signers can send their signatures to a third party who will aggregate them, removing the need for further interaction and for all parties to be online at the same time.")]),e._v(" "),i("div",{staticClass:"custom-block tip"},[i("p",[e._v("This section is taken from the Section 1 of the "),i("a",{attrs:{href:"https://crypto.stanford.edu/~dabo/pubs/papers/BLSmultisig.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("official related post"),i("OutboundLink")],1),e._v(" by Dan Boneh et al")])]),e._v(" "),i("ol",[i("li",[i("p",[e._v("Call "),i("code",[e._v("e: G_0 x G_1 → G_T")]),e._v(" a bilinear non-degenerate pairing that’s efficient o compute, "),i("code",[e._v("g_0")]),e._v(" and "),i("code",[e._v("g_1")]),e._v(" generators of "),i("code",[e._v("G_0")]),e._v(" and "),i("code",[e._v("G_1")]),e._v(" respectively.")])]),e._v(" "),i("li",[i("p",[e._v("Call "),i("code",[e._v("sk")]),e._v(" the user’s secret key, and "),i("code",[e._v("g_1^{sk}")]),e._v(" their public key.")])]),e._v(" "),i("li",[i("p",[e._v("Call "),i("code",[e._v("H_0")]),e._v(" a cryptographic hash function from the message space to "),i("code",[e._v("G_0")])])]),e._v(" "),i("li",[i("p",[e._v("Call "),i("code",[e._v("H_1")]),e._v(" a cryptographic hash function from "),i("code",[e._v("G_1^n")]),e._v(" to "),i("code",[e._v("R^n")])])]),e._v(" "),i("li",[i("p",[e._v("A signature on "),i("code",[e._v("m")]),e._v(" is "),i("code",[e._v("s_i = Η_0(m)^sk_i")])])]),e._v(" "),i("li",[i("p",[e._v("To aggregate N signatures for the same message from public keys "),i("code",[e._v("(pk_1, …​, pk_n)")]),e._v(":")]),e._v(" "),i("ol",[i("li",[e._v("Compute: "),i("code",[e._v("(t_1, …​, t_n) = H_1(pk_1, …​, pk_n)")])]),e._v(" "),i("li",[e._v("Aggregated signature: "),i("code",[e._v("s = s_1^t_1 * …​ * s_n^t_n")])])])]),e._v(" "),i("li",[i("p",[e._v("To verify the aggregated signature against the same public keys:")]),e._v(" "),i("ol",[i("li",[e._v("Compute: "),i("code",[e._v("(t_1, …​, t_n) = H_1(pk_1, …​, pk_n)")])]),e._v(" "),i("li",[e._v("Compute the aggregate public key: "),i("code",[e._v("pk = pk_1 ^ t_1 * …​ * pk_n ^ t_n")]),e._v(" (independent of the message being signed))")]),e._v(" "),i("li",[e._v("Verify the signature: "),i("code",[e._v("e(g_1, s) = e(pk, H_0(m))")]),e._v(" (requires 2 pairings since the same message is being signed):")])])])])])}),[],!1,null,null,null);t.default=a.exports}}]);